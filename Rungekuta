#include <stdlib.h>
#include <time.h>
#include<iostream>
#include<math.h>
#include <fstream>
using namespace std;

int main()
{
    //Declaracion de variables
    int i,j,k,z,cont;
    double y[10],f[10], k1[10], k2[10], k3[10], k4[10];
    double r, tetha, Pr, Ptetha, xnave, ynave, xluna, yluna,xmeteorito, ymeteorito,distancialuna,distanciatierra, epsilonmax,s, hmax,h,t,rtierra;
    double omega, Delta ,r_prima, u, d, pi,p,t1, r1,r2,r3,dtl,tmision,Ec1,Ec2,Ep1,Ep2,m,gasto,gastofinal,Enuclear,v;
    double ym[6],fm[6], k1m[6], k2m[6], k3m[6], k4m[6];
    double rm, tetham, Prm, Ptetham, masam,r_primam, vector_nave_meteorito,distancia_nave_meteorito,resta,R,Rprima,dis;

    ofstream posicion_nave, posicion_luna,P_r,P_tetha,posicion_meteorito;

    posicion_nave.open("posicion_nave.txt",ios::out);
    posicion_luna.open("posicion_luna.txt",ios::out);
    P_r.open("Pr.txt",ios::out);
    P_tetha.open("Ptetha.txt",ios::out);
    posicion_meteorito.open("posicion_meteorito.txt",ios::out);

    cont=0;
    gasto=0.0;
    m=500000.0;
    Enuclear=5*4.1E+16;




    //Decidimos de cuanto va a ser el paso

    h=5.0;

    z=0;

    //Ahora definimos algunas constantes que nos haran falta

    Delta=7.014744145E-12;
    u=0.01230246418;

    //2.6617E-6

    omega=2.6617E-6;
    d=3.844E8;
    pi=3.14159;
    p=7.0E-7;

    dtl=384400000.0;
    masam=2080*4/3*pi*10000.0*10000.0*10000.0;

    //Ahora necestitamos Indicar cuales van a ser
    //las condiciones iniciales

    r=0.50;
    tetha=23.45/360.0*2.0*pi;
    Pr=3.0E-5;
    Ptetha=0.0;
    rtierra=0.0165925;

    R=5.61511E-7/6.5;
    dis=2.0*10000.0/tan(R)/dtl;
    cout<<dis<<endl;

    //condiciones inciales del meteorito


    //Definimos la y inicial de nuestro algoritmo para la nave

    y[1]=rtierra;
    y[2]=tetha;
    y[3]=Pr;
    y[4]=Ptetha;


    //Definimos las condiones iniciales para el meteorito
    y[5]=166.7;
    y[6]=0.0;
    y[7]=-5000.0/(dtl);
    y[8]=0.0;

    Ec1=0.5*m*dtl*dtl*(y[3]*y[3]+y[4]*y[4]/(y[1]*y[1]));
    gasto=Ec1;

    t=0.0;
    cout<<1.0*y[3]*dtl<<endl;

    //Vamos con el algoritmo principal


        for(j=0;j<=10000000;j++)
        {
            for(k=1;k<=2;k++)
            {
                if(cont==0)
    {
                xnave=y[1]*cos(y[2]);
                ynave=y[1]*sin(y[2]);

                xmeteorito=y[5]*cos(y[6]);
                ymeteorito=y[5]*sin(y[6]);

                xluna=cos(omega*t);
                yluna=sin(omega*t);


                distancialuna=sqrt((xnave-xluna)*(xnave-xluna)+(ynave-yluna)*(ynave-yluna));
                distancia_nave_meteorito=sqrt((xnave-xmeteorito)*(xnave-xmeteorito)+(ynave-ymeteorito)*(ynave-ymeteorito));



                /*  if(y[1]<(rtierra*0.95))
                {
                    cout<<"choque con la tierra en t="<<t<<endl;
                }

                if(distancialuna<0.043)
                {
                    cout<<"choque con la luna en t="<<t<<endl;
                }

                if(y[1]>2.0)
                {
                    cout<<"Me he ido a wisconsin en t="<<t<<endl;
                }
                */


                if(j%1000==0)
                {
                    posicion_nave<<xnave<<", "<<ynave<<endl;
                    posicion_nave<<xmeteorito<<", "<<ymeteorito<<endl;
                    posicion_nave<<xluna<<", "<<yluna<<endl<<endl;
                }


                //Definimos r' de las dos formas que vamos a necesitar


                r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
                r_primam=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));


                //Actualizamos los valores de f a los calculados en el paso anterior

                f[1]=y[3];
                f[2]=y[4]/(y[1]*y[1]);
                f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
                f[4]=-(Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t));

                f[5]=y[7];
                f[6]=y[8]/(y[5]*y[5]);
                f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
                f[4]=-(Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t));


                //Definimos las "k" y calculamos "y"


            //Calculamos todos los k1

                for(i=1;i<=8;i++)
                {
                    k1[i]=h*f[i];
                }

                //Hacemos que los y se les sume k1/2 para poder calcular k2

                for(i=1;i<=8;i++)
                {
                    y[i]=y[i]+k1[i]/2.0;
                }

                t=t+h/2.0;

                r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
                f[1]=y[3];
                f[2]=y[4]/(y[1]*y[1]);
                f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
                f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

                r_primam=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
                f[5]=y[7];
                f[6]=y[8]/(y[5]*y[5]);
                f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
                f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);

                t=t-h/2.0;


                //Calculamos todos los k2

                for(i=1;i<=8;i++)
                {
                    k2[i]=h*f[i];
                }

                //Hacemos que los y se les sume k2/2 para podercalcular k3

                for(i=1;i<=8;i++)
                {
                    y[i]=y[i]-k1[i]/2.0+k2[i]/2.0;
                }

                t=t+h/2.0;

                r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
                f[1]=y[3];
                f[2]=y[4]/(y[1]*y[1]);
                f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
                f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

                r_prima=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
                f[5]=y[7];
                f[6]=y[8]/(y[5]*y[5]);
                f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
                f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);


                //Calculamos los k3

                for(i=1;i<=8;i++)
                {
                    k3[i]=h*f[i];
                }

                //Ahora necesitamos sumar k3 para calcular k4

                for(i=1;i<=8;i++)
                {
                    y[i]=y[i]-k2[i]/2.0+k3[i];
                }

                t=t+h;

                r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
                f[1]=y[3];
                f[2]=y[4]/(y[1]*y[1]);
                f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
                f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

                r_prima=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
                f[5]=y[7];
                f[6]=y[8]/(y[5]*y[5]);
                f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
                f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);

                t=t-h;

                //Calculamos los k4

                for(i=1;i<=8;i++)
                {
                    k4[i]=h*f[i];
                }

                //Recuperamos los valores originales de los "y" para
                //poder calcular los del instante siguiente

                for(i=1;i<=8;i++)
                {
                    y[i]=y[i]-k3[i];
                }

                //Calculamos los "y" en el instante siguiente

                for(i=1;i<=8;i++)
                {
                    y[i]=y[i]+1/6.0*(k1[i]+2*k2[i]+2*k3[i]+k4[i]);
                }

                t1=t;
                t=t+h;

                Ec1=0.5*m*dtl*dtl*(y[3]*y[3]+y[4]*y[4]/(y[1]*y[1]));


                if(abs(cos(y[2])-cos(y[6]))<=0.0001 & abs(sin(y[2])-sin(y[6]))<=0.0001)
                {



                    v=sqrt(y[3]*y[3]*dtl*dtl+y[4]*y[4]/y[1]/y[1]*dtl*dtl);
                    y[4]=0.0;


                }

                if((y[5]-y[1])<=10000.0/dtl)
                {


                    y[3]=y[7];
                    y[4]=y[8];
                    v=sqrt(y[3]*y[3]*dtl*dtl+y[4]*y[4]/y[1]/y[1]*dtl*dtl);


                    cont++;
                }


                Ec2=0.5*m*dtl*dtl*(y[3]*y[3]+y[4]*y[4]/(y[1]*y[1]));;
                gasto=gasto+abs(Ec1-Ec2);

                if(cont==1)
                {
                   cout<<endl<<t/3600.0/24.0<<"   "<<y[1];
                    tmision=t;
                    gastofinal=gasto;
                    m=masam/2.0;
                masam=masam/2.0;
               // y[1]=42.2;
                y[5]=y[1];
                y[4]=y[1]/dtl*sqrt(Enuclear/(2.0*masam));
                y[8]=-y[4];

                }
            }

          if(cont>=1)
          {

                xnave=y[1]*cos(y[2]);
                ynave=y[1]*sin(y[2]);

                xmeteorito=y[5]*cos(y[6]);
                ymeteorito=y[5]*sin(y[6]);

                xluna=cos(omega*t);
                yluna=sin(omega*t);


                distancialuna=sqrt((xnave-xluna)*(xnave-xluna)+(ynave-yluna)*(ynave-yluna));
                distancia_nave_meteorito=sqrt((xnave-xmeteorito)*(xnave-xmeteorito)+(ynave-ymeteorito)*(ynave-ymeteorito));



        if(y[1]<(rtierra*1.0) || y[5]<(rtierra*1.0) )
        {
            cout<<"choque con la tierra en t="<<t<<endl;
        }








        if(j%1000==0)
           {
                posicion_nave<<xnave<<", "<<ynave<<endl;
                posicion_nave<<xmeteorito<<", "<<ymeteorito<<endl;

                posicion_nave<<xluna<<", "<<yluna<<endl<<endl;
           }





        //Definimos r' de las dos formas que vamos a necesitar


        r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
        r_primam=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));


        //Actualizamos los valores de f a los calculados en el paso anterior

        f[1]=y[3];
        f[2]=y[4]/(y[1]*y[1]);
        f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
        f[4]=-(Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t));

        f[5]=y[7];
        f[6]=y[8]/(y[5]*y[5]);
        f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
        f[4]=-(Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t));


        //Definimos las "k" y calculamos "y"



        //Calculamos todos los k1

        for(i=1;i<=8;i++)
        {
            k1[i]=h*f[i];
        }

        //Hacemos que los y se les sume k1/2 para poder calcular k2

        for(i=1;i<=8;i++)
        {
            y[i]=y[i]+k1[i]/2.0;
        }

        t=t+h/2.0;

        r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
        f[1]=y[3];
        f[2]=y[4]/(y[1]*y[1]);
        f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
        f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

        r_primam=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
        f[5]=y[7];
        f[6]=y[8]/(y[5]*y[5]);
        f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
        f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);

        t=t-h/2.0;


        //Calculamos todos los k2

        for(i=1;i<=8;i++)
        {
            k2[i]=h*f[i];
        }

        //Hacemos que los y se les sume k2/2 para podercalcular k3

        for(i=1;i<=8;i++)
        {
            y[i]=y[i]-k1[i]/2.0+k2[i]/2.0;
        }

        t=t+h/2.0;

        r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
        f[1]=y[3];
        f[2]=y[4]/(y[1]*y[1]);
        f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
        f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

        r_prima=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
        f[5]=y[7];
        f[6]=y[8]/(y[5]*y[5]);
        f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
        f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);


        //Calculamos los k3

        for(i=1;i<=8;i++)
        {
            k3[i]=h*f[i];
        }

        //Ahora necesitamos sumar k3 para calcular k4

        for(i=1;i<=8;i++)
        {
            y[i]=y[i]-k2[i]/2.0+k3[i];
        }

        t=t+h;

        r_prima=sqrt(1.0+y[1]*y[1]-2.0*y[1]*cos(y[2]-omega*t));
        f[1]=y[3];
        f[2]=y[4]/(y[1]*y[1]);
        f[3]=y[4]*y[4]/(y[1]*y[1]*y[1])-Delta*(1.0/(y[1]*y[1])+u/(r_prima*r_prima*r_prima)*(y[1]-cos(y[2]-omega*t)));
        f[4]=-Delta*u*y[1]/(r_prima*r_prima*r_prima)*sin(y[2]-omega*t);

        r_prima=sqrt(1.0+y[5]*y[5]-2.0*y[5]*cos(y[6]-omega*t));
        f[5]=y[7];
        f[6]=y[8]/(y[5]*y[5]);
        f[7]=y[8]*y[8]/(y[5]*y[5]*y[5])-Delta*(1.0/(y[5]*y[5])+u/(r_primam*r_primam*r_primam)*(y[5]-cos(y[6]-omega*t)));
        f[8]=-Delta*u*y[5]/(r_primam*r_primam*r_primam)*sin(y[6]-omega*t);

        t=t-h;

        //Calculamos los k4

        for(i=1;i<=8;i++)
        {
            k4[i]=h*f[i];
        }

        //Recuperamos los valores originales de los "y" para
        //poder calcular los del instante siguiente

        for(i=1;i<=8;i++)
        {
            y[i]=y[i]-k3[i];
        }

        //Calculamos los "y" en el instante siguiente

        for(i=1;i<=8;i++)
        {
            y[i]=y[i]+1/6.0*(k1[i]+2*k2[i]+2*k3[i]+k4[i]);
        }

         t1=t;
         t=t+h;
          }

        }
    }

    if(cont>0)
    {
        cout<<"Mision cumplida en "<<t/3600.0/24.0<<" segundos"<<endl<<"Gasto energetico "<<gastofinal<<" Julios";
    }

    posicion_luna.close();
    posicion_nave.close();
    P_r.close();
    P_tetha.close();
    return 0;
}
